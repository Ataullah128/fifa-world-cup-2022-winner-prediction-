# -*- coding: utf-8 -*-
"""fifa-world-cup-winner-2022 final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QlMnk4cdfTAHaPC07Fjx5ALPje88sAzD

<h1 style="color:#7F1431">Contents</h1>

* [1. In this Notebook](#NB_desc)<br>
* [2. Setting up our Enviroment & Explore dataset](#setting_env)<br>
* [3. Preprocecssing](#prep)<br>
    * [Handling Nulls.](#nulls)
    * [Duplicates.](#duplicates)
    * [Outliers.](#Outliers)
* [5. Data Analysis](#DA)<br>
"""

from google.colab import drive
drive.mount('/content/drive')

import os 
import gc
import time
import warnings
import numpy as np
import pandas as pd
from tqdm import tqdm
from itertools import combinations

from matplotlib import pyplot as plt
import seaborn as sns
import missingno
from termcolor import colored, cprint

import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder, OrdinalEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score, auc, roc_curve
from xgboost import XGBClassifier

# configurations
warnings.simplefilter('ignore')
pd.set_option('display.max_columns', None)
plt.style.use('ggplot')
sns.set_palette('dark')

SIGMA = 3
SEPARATOR = colored(200*'=', 'red')
teams_worldcup = ['Qatar', 'Ecuador', 'Senegal', 'Netherlands', 'England', 'IR Iran', 'USA',
                  'Wales', 'Argentina', 'Saudi Arabia', 'Mexico', 'Poland', 'France', 
                  'Australia', 'Denmark', 'Tunisia', 'Spain', 'Costa Rica', 'Germany', 
                  'Japan', 'Belgium', 'Canada', 'Morocco', 'Croatia', 'Brazil', 'Serbia', 
                  'Switzerland', 'Cameroon', 'Portugal', 'Ghana', 'Uruguay', 'Korea Republic']

df = pd.read_csv('//content/drive/MyDrive/international_matches.csv')
display(df.sample(5))
print(SEPARATOR)
display(df.describe())
print(SEPARATOR)
display(df.select_dtypes(include='object').describe())
print(SEPARATOR)
display(df.info())
print(SEPARATOR)
display(df.dtypes)

df.isnull().sum()

"""<a id='nulls'></a>
<h1 style="color:#7f1431">Handle Nulls</h1>
"""

per_date = df.set_index('date').copy()
Nulls = per_date.isnull().sum().sort_values(ascending=False)
median = np.median(Nulls[Nulls>0].values)

fig, axs = plt.subplots(1, 2, figsize=(30, 8))
missingno.matrix(per_date, ax=axs[0])
axs[0].set_title('Distribution of Nulls in each column', size=20);axs[0].set_xlabel('Column Name', size=20);axs[0].set_ylabel('Index', size=20);

sns.barplot(x=Nulls.index, y=Nulls.values, ax=axs[1], palette='RdBu')
axs[1].tick_params(labelrotation=45)
axs[1].axhline(median, color='#000000')
axs[1].set_title('Number of Nulls in each column', size=20);axs[1].set_xlabel('Column Name', size=20);axs[1].set_ylabel('Number of Nulls', size=20);

"""

#. Nulls are in score columns only.
#. It seems that there are some nulls that are not normally distributed (major nulls are in top rows).
"""

df['year'] = pd.to_datetime(df['date']).dt.year
nulls_per_year = pd.pivot_table(df, index=['year'], aggfunc=lambda x : x.isnull().mean() / 0.08).sum(1).sort_index()
fig = go.Figure(go.Scatter(x=nulls_per_year.index, y=nulls_per_year.values, mode='lines+markers'))
fig.update_layout(xaxis={'title':{'text':'year', 'font':{'size':20, 'color':'#7F1431'}}}, 
                  yaxis={'title':{'text':'Percentage of Nulls', 'font':{'size':20, 'color':'#7F1431'}}}, 
                  title={'text':"Percentage of nulls every year", 'font':{'size':25}})

"""### As expeced most nulls are in matches that were played before `2005`
#### This may be due to there wasn't these advanced analysis devices existing today.

### I will complete with these nulls for now, with taking these nulls in consideration while going on, in order to avoid losing much information.

<a id=duplicates></a>
<h1 style="color:#7f1431">Duplicates</h1>
"""

print(f"Number of Duplicte rows in this dataset: {colored(df.duplicated().sum(), 'red')}")

df.shape

"""<a id=outliers></a>
<h1 style="color:#7f1431">Outliers</h1>
"""

columns = df.select_dtypes(exclude='object').columns
n_cols = 2
n_rows = len(columns) // n_cols + 1

fig = make_subplots(rows=n_rows, cols=n_cols, subplot_titles=columns)

for i, col in enumerate(columns):
    fig.add_trace(go.Box(x=df[col], name=col),
                  row=i//n_cols+1, col=int(i%n_cols)+1)
    
fig.update_yaxes(visible=False, showticklabels=False)
fig.update_layout(height=1080)
fig.show()

fig = make_subplots(2, 2, subplot_titles=['Home team points distribution', 'Away team points distribution', 'Home team points per year', 'Away team points per year'])
trace1 = go.Histogram(x=df['home_team_total_fifa_points'], name='Home Team')
fig.add_trace(trace1, row=1, col=1)
trace2 = go.Histogram(x=df['away_team_total_fifa_points'], name='Away Team')
fig.add_trace(trace2, row=1, col=2)


home_team_points_per_year = df.groupby('year')['home_team_total_fifa_points'].mean()
away_team_points_per_year = df.groupby('year')['away_team_total_fifa_points'].mean()


trace1 = go.Bar(x=home_team_points_per_year.index, y=home_team_points_per_year.values, name='home')
fig.add_trace(trace1, 2, 1)
trace2 = go.Bar(x=away_team_points_per_year.index, y=away_team_points_per_year.values, name='away')
fig.add_trace(trace2, 2, 2)

"""> <font size=4>As I have mentioned, there are many nantion teams with zero FIFA points, and it seems these values are not true, All teams before 2011 have `zero` fifa points.

### So I am going to replace all zero values with weighted average values (large weight of points near to our record's year and low weight otherwise).

<h1 style="color:#7f1431">Note:</h1> 

#### I will use weighted average so I will use a gaussina kernel in order to give near points more weights, 
#### Gaussian kernel Equation:

$$ G(x) = \frac{1}{\sqrt{2\pi} \times \sigma} . e^{\frac{- x^2}{2\sigma^2}}$$
"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# home_indices = df.loc[df.home_team_total_fifa_points>0].groupby('home_team').groups
# away_indices = df.loc[df.away_team_total_fifa_points>0].groupby('away_team').groups
# 
# gaussian = lambda x : 1 / (np.sqrt(2*np.pi) * SIGMA) * np.exp(- np.power(x, 2) / (2*np.power(SIGMA, 2)))
# 
# def get_points(row_idx:float, home:bool=True) -> float:
#     '''
#     Args: 
#         row_idx: index of row that have zero total fifa points.
#         home: boolen flag to indicate whether to modify home or away team.
#     
#     Returns:
#         weighted_points: new fifa point of this team.
#         
#     '''
#     row = df.iloc[row_idx]
#     year=row.year
#     if home:
#         team = row.home_team
#         indices = home_indices
#     else:
#         team = row.away_team
#         indices = away_indices
#         
#     years_points = df.loc[indices[team], ['year', 'home_team_total_fifa_points']].values.reshape(-1, 2)
#     years = years_points[:, 0]
#     points = years_points[:, 1]
#     time_distance = years - year
#     weights = gaussian(time_distance)
#     weights = weights / np.sum(weights)
#     weighted_points = weights * points
#     return weighted_points.mean()
# 
# 
# for year in range(2010, 1993, -1):
#     home_zero_points_rows = pd.Series(df.loc[(df['home_team_total_fifa_points']==0).values & (df['year']==year).values].index)
#     home = home_zero_points_rows.apply(get_points)
#     df.loc[(df['home_team_total_fifa_points']==0).values & (df['year']==year).values, 'home_team_total_fifa_points'] = home.values
#     
#     away_zero_points_rows = pd.Series(df.loc[(df['away_team_total_fifa_points']==0).values & (df['year']==year).values].index)
#     away = away_zero_points_rows.apply(lambda x : get_points(x, home=False))
#     df.loc[(df['away_team_total_fifa_points']==0).values & (df['year']==year).values, 'away_team_total_fifa_points'] = away.values

fifa_rank = df[['date','home_team','away_team','home_team_fifa_rank','away_team_fifa_rank','away_team_total_fifa_points','home_team_total_fifa_points']]

home = fifa_rank[['date','home_team','home_team_fifa_rank','home_team_total_fifa_points']].rename(columns = {'home_team':'team', 'home_team_fifa_rank':'rank','home_team_total_fifa_points':'rank_points'})
away = fifa_rank[['date','away_team','away_team_fifa_rank','away_team_total_fifa_points']].rename(columns = {'away_team':'team', 'away_team_fifa_rank':'rank','away_team_total_fifa_points':'rank_points'})
fifa_rank = home.append(away)
fifa_rank = fifa_rank.sort_values(['team','date'],ascending = [True,False])
fifa_rank['row_number']= fifa_rank.groupby('team').cumcount()+1
fifa_rank_top = fifa_rank[fifa_rank['row_number']==1].drop('row_number',axis=1).nsmallest(10,'rank')

#5 Strongest teams
fifa_rank_top

import plotly.express as px

"""# data analysis"""

fifa_rank = df[['date','home_team','away_team','home_team_fifa_rank', 'away_team_fifa_rank']]
home = fifa_rank[['date','home_team','home_team_fifa_rank']].rename(columns={"home_team":"team","home_team_fifa_rank":"rank"})
away = fifa_rank[['date','away_team','away_team_fifa_rank']].rename(columns={"away_team":"team","away_team_fifa_rank":"rank"})
fifa_rank = pd.concat([home,away])
#Select each country latest match
fifa_rank = fifa_rank.sort_values(['team','date'],ascending=[True,False])
fifa_rank_top10 = fifa_rank.groupby('team').first().sort_values('rank',ascending=True)[0:10].reset_index()
fifa_rank_top10

plt.figure(figsize=(10,4),dpi=200)
sns.barplot(data=fifa_rank_top10,y='team',x='rank')
plt.title("Top 10 teams");

"""## Win percentage of Top 10 Teams"""

def home_percentage(team):
    score = len(df[(df['home_team'] == team) & (df['home_team_result'] == "Win")]) / len(df[df['home_team'] == team]) * 100
    return round(score)
def away_percentage(team):
    score = len(df[(df['away_team'] == team) & (df['home_team_result'] == "Lose")]) / len(df[df['away_team'] == team]) * 100
    return round(score)

fifa_rank_top10['Home_win_Per'] = np.vectorize(home_percentage)(fifa_rank_top10['team'])
fifa_rank_top10['Away_win_Per'] = np.vectorize(away_percentage)(fifa_rank_top10['team'])
fifa_rank_top10['Average_win_Per'] = round((fifa_rank_top10['Home_win_Per'] + fifa_rank_top10['Away_win_Per'])/2)
fifa_rank_win = fifa_rank_top10.sort_values('Average_win_Per',ascending=False)
fifa_rank_win

sns.barplot(data=fifa_rank_win,x='Average_win_Per',y='team')
plt.title("Top 10 teams Average Winning Percentage");



"""## Top 10 Attacking **team**"""

fifa_offense = df[['date', 'home_team', 'away_team','home_team_mean_offense_score','away_team_mean_offense_score']]
home = fifa_offense[['date','home_team','home_team_mean_offense_score']].rename(columns={"home_team":"team","home_team_mean_offense_score":"offense_score"})
away = fifa_offense[['date','away_team','away_team_mean_offense_score']].rename(columns={"away_team":"team","away_team_mean_offense_score":"offense_score"})
fifa_offense = pd.concat([home,away])
fifa_offense = fifa_offense.sort_values(['date','team'],ascending=[False,True])
fifa_offense_top10 = fifa_offense.groupby('team').first().sort_values('offense_score',ascending=False)[0:10].reset_index()
fifa_offense_top10

sns.barplot(data=fifa_offense_top10,x='offense_score',y='team')
plt.title("Top 10 Attacking teams");

"""# Top 10 modified Teams"""

fifa_midfield = df[['date', 'home_team', 'away_team','home_team_mean_midfield_score','away_team_mean_midfield_score']]
home = fifa_midfield[['date','home_team','home_team_mean_midfield_score']].rename(columns={"home_team":"team","home_team_mean_midfield_score":"midfield_score"})
away = fifa_midfield[['date','away_team','away_team_mean_midfield_score']].rename(columns={"away_team":"team","away_team_mean_midfield_score":"midfield_score"})
fifa_midfield = pd.concat([home,away])
fifa_midfield = fifa_midfield.sort_values(['date','team'],ascending=[False,True])
fifa_midfield_top10 = fifa_midfield.groupby('team').first().sort_values('midfield_score',ascending=False)[0:10].reset_index()
fifa_midfield_top10

sns.barplot(data=fifa_midfield_top10,x='midfield_score',y='team')
plt.title("Top 10 Midfield teams");

"""## Top 10 defence teams"""

fifa_defense = df[['date', 'home_team', 'away_team','home_team_mean_defense_score','away_team_mean_defense_score']]
home = fifa_defense[['date','home_team','home_team_mean_defense_score']].rename(columns={"home_team":"team","home_team_mean_defense_score":"defense_score"})
away = fifa_defense[['date','away_team','away_team_mean_defense_score']].rename(columns={"away_team":"team","away_team_mean_defense_score":"defense_score"})
fifa_defense = pd.concat([home,away])
fifa_defense = fifa_defense.sort_values(['date','team'],ascending=[False,True])
fifa_defense_top10 = fifa_defense.groupby('team').first().sort_values('defense_score',ascending=False)[0:10].reset_index()
fifa_defense_top10

sns.barplot(data=fifa_defense_top10,x='defense_score',y='team')
plt.title("Top 10 Defense Teams")

"""# correlations"""

from copy import copy
final_df = copy(df)

final_df['home_team_result'] = final_df['home_team_result'].map({'Win':1, 'Draw':2, 'Lose':0})

final_df.corr()['home_team_result'].sort_values(ascending=False)

#Dropping unnecessary colums
final_df = final_df.drop(['date', 'home_team_continent','away_team_continent','home_team_total_fifa_points', 'away_team_total_fifa_points','home_team_score', 'away_team_score', 'tournament', 'city', 'country','neutral_location', 'shoot_out'],axis=1)

#change column names
final_df.rename(columns={"home_team":"Team1", "away_team": "Team2", "home_team_fifa_rank": "Team1_FIFA_RANK", 
                         "away_team_fifa_rank":"Team2_FIFA_RANK", "home_team_result":"Team1_Result", "home_team_goalkeeper_score":"Team1_Goalkeeper_Score",
                        "away_team_goalkeeper_score":"Team2_Goalkeeper_Score", "home_team_mean_defense_score":"Team1_Defense",
                        "home_team_mean_offense_score":"Team1_Offense", "home_team_mean_midfield_score":"Team1_Midfield",
                        "away_team_mean_defense_score":"Team2_Defense", "away_team_mean_offense_score":"Team2_Offense",
                        "away_team_mean_midfield_score":"Team2_Midfield"},inplace=True)

plt.figure(figsize=(10,4),dpi=200)
sns.heatmap(final_df.corr(),annot=True)



"""It would be a mess if I would do these analysis using python (plotly), So I would rather move to tableau to have more more functionality and interactivity. 
     but first we need to do some preprocessing in this data to be ready for analysis

Prepare data for Analysis

We can split our data in terms of analysis into two main categories
     per team analysis.
     per match analysis.
"""

def mode(arr):
    srtd_lst, cnt = np.unique(arr, return_counts=True)
    return srtd_lst[np.argmax(cnt)]

# Home win | draw | lose
df['home_win'] = df['home_team_result'].apply(lambda x : x=='Win')
df['home_draw'] = df['home_team_result'].apply(lambda x : x=='Draw')
df['home_lose'] = df['home_team_result'].apply(lambda x : x=='Lose')

# per team table
per_team = pd.DataFrame(df.groupby('home_team')['home_win'].sum())
per_team['home_draw'] = df.groupby('home_team')['home_draw'].sum().values
per_team['home_loss'] = df.groupby('home_team')['home_lose'].sum().values

per_team['away_win']  = df.groupby('away_team')['home_lose'].sum().values
per_team['away_draw']  = df.groupby('away_team')['home_draw'].sum().values
per_team['away_win']  = df.groupby('away_team')['home_win'].sum().values

per_team['continent'] = df.groupby('home_team')['home_team_continent'].apply(mode).values

per_team['avg_FIFA_points'] = (df.groupby('home_team')['home_team_total_fifa_points'].mean().values + df.groupby('away_team')['away_team_total_fifa_points'].mean().values) / 2
per_team['median_FIFA_rank'] = df.groupby('home_team')['home_team_fifa_rank'].median().values

per_team['home_goal_scored'] = df.groupby(['home_team'])['home_team_score'].sum()
per_team['home_goal_conceded'] = df.groupby(['home_team'])['away_team_score'].sum()
per_team['away_goal_scored'] = df.groupby(['away_team'])['away_team_score'].sum()
per_team['away_goal_conceded'] = df.groupby(['away_team'])['home_team_score'].sum()

per_team.head()

df.to_csv('matches.csv', index=False)

#1. In this Notebook
#2. Setting up our Enviroment & Explore dataset
# 3. Preprocecssing

import os 
import gc
import time
import warnings
import numpy as np
import pandas as pd
from tqdm import tqdm
from itertools import combinations

from matplotlib import pyplot as plt
import seaborn as sns
import missingno
from termcolor import colored, cprint

import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder, OrdinalEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score, auc, roc_curve
from xgboost import XGBClassifier
from sklearn.tree import DecisionTreeClassifier
import tensorflow as tf
import tensorflow.keras as keras
import keras.layers as layers
import keras.callbacks as cb
from tensorflow.keras.utils import plot_model

# configurations
warnings.simplefilter('ignore')
pd.set_option('display.max_columns', None)
plt.style.use('ggplot')
sns.set_palette('dark')

SEED = 101
SEPARATOR = colored(200*'=', 'red')
teams_worldcup = ['Qatar', 'Ecuador', 'Senegal', 'Netherlands', 'England', 'IR Iran', 'USA',
                  'Wales', 'Argentina', 'Saudi Arabia', 'Mexico', 'Poland', 'France', 
                  'Australia', 'Denmark', 'Tunisia', 'Spain', 'Costa Rica', 'Germany', 
                  'Japan', 'Belgium', 'Canada', 'Morocco', 'Croatia', 'Brazil', 'Serbia', 
                  'Switzerland', 'Cameroon', 'Portugal', 'Ghana', 'Uruguay', 'Korea Republic']
tf.random.set_seed(SEED)
np.random.seed(101)

df = pd.read_csv(r'/content/drive/MyDrive/matches.csv')#.drop('Unnamed: 0', axis=1)

"""# Feature Engineering

Columns will remain:
home_team, away_team.
home_team_continent, away_team_continent.
home_team_total_fifa_score, away_team_total_fifa_score.
home_team_fifa_rank, away_team_fifa_rank.
shoot_out
home_team_GK_score, away_team_GK_score.
home_team_mean_offense_score, away_team_mean_offense_score.
home_team_mean_defense_score, home_team_mean_defense_score.
home_team_mean_midfield_score, home_team_mean_midfield_score.
Columns will be dr
city.opped:
Date.
home_team_score, away_team_score.
tournament.
country.
neutral_location.
year.
Columns will be created
total_fifa_points_diff, total_fifa_points_sum.
fifa_rank_diff, fifa_rank_sum.
tournament_rank (international, national, friendly)
"""

def get_tournament_rank(tournament):
    if ('FIFA World Cup' in tournament or 'Confederations' in tournament):
        return 'International'
    elif (tournament == 'Friendly'):
        return tournament
    elif ('UEFA' in tournament):
        return 'Europe'
    elif ('African' in tournament):
        return 'Africa'
    elif ('AFC' in tournament):
        return 'Asia'
    elif ('CONCACAF' in tournament):
        return 'North America'
    elif ('Copa' in tournament):
        return 'South America'
    else :
        return 'Other'

columns_to_drop = ['home_team', 'away_team', 'home_team_score', 'away_team_score', 'date', 'tournament', 'city', 'country', 'neutral_location', 'home_win', 'home_draw', 'home_lose',
                   'tournament', 'tournament_rank', 'home_team_result', 
                   'home_team_continent', 'away_team_continent', 'year']
    
    
df['total_fifa_points_diff'] = df['home_team_total_fifa_points'] - df['away_team_total_fifa_points']
df['total_fifa_points_sum'] = df['home_team_total_fifa_points'] + df['away_team_total_fifa_points']
df['fifa_rank_diff'] = df['home_team_fifa_rank'] - df['away_team_fifa_rank']
df['fifa_rank_sum'] = df['home_team_fifa_rank'] + df['away_team_fifa_rank']
df['tournament_rank'] = df['tournament'].apply(get_tournament_rank)

# Encode categorical features
# 1. trounament rank
tournament_rank_encoder = OneHotEncoder(drop='first').fit(df['tournament_rank'].values.reshape(-1, 1))
tournament_rank = tournament_rank_encoder.transform(df['tournament_rank'].values.reshape(-1, 1)).toarray()
tournament_rank = pd.DataFrame(tournament_rank, columns=['tournament' + str(i) for i in range(tournament_rank.shape[1])])
df = pd.concat([df, tournament_rank], axis=1)

# 2. shoot_out
df['shoot_out'] = (df['shoot_out']=='Yes').astype(int)

# 3. continent
continent_encoder = OrdinalEncoder()
continent_encoder.fit(df['home_team_continent'].values.reshape(-1, 1))
df['home_team_continent_encoded'] = continent_encoder.transform(df['home_team_continent'].values.reshape(-1, 1))
df['away_team_continent_encoded'] = continent_encoder.transform(df['away_team_continent'].values.reshape(-1, 1))


# fill nulls in score columns -> I will fill these nulls using bfill (as data is sorted at time, so goal keeper will take score of his next match)
df = df.fillna(method='bfill')
df = df.fillna(method='ffill')


X = df.drop(columns_to_drop, axis=1)
y = (df['home_team_result'] == 'Win').astype(int)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=101, shuffle=True)
# X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.2, shuffle=True, random_state=101)

"""# Model Trainig

"""

def evaluate(y_pred, y_true):
    print(f"Accuracy score: {colored(accuracy_score(y_pred, y_true)*100, 'red')}")
    cm = confusion_matrix(y_pred, y_true)
    sns.heatmap(cm, annot=True, fmt='.2f', center=True)
    plt.show()
    print(classification_report(y_pred, y_true))
    
    fpr, tpr, thresholds = roc_curve(y_pred, y_true)
    print(f'AUC: {colored(auc(fpr, tpr) * 100, "red")}')
    
    plt.plot(fpr, tpr)
    plt.plot([0, 1], [0, 1], color="navy", lw=2, linestyle="--")

activation = 'elu'

keras_model = keras.Sequential([
    layers.Dense(units=32, input_shape=(X.shape[1:])),
    layers.BatchNormalization(), 
    layers.Activation(activation), 
    layers.Dropout(0.2), 
    
    layers.Dense(units=40), 
    layers.BatchNormalization(), 
    layers.Activation(activation), 
    
    layers.Dense(units=20), 
    layers.BatchNormalization(), 
    layers.Activation(activation), 
    
    layers.Dense(units=8), 
    layers.BatchNormalization(), 
    layers.Activation(activation), 
    
    layers.Dense(units=1, activation='sigmoid')    
])

fig = plot_model(keras_model)

es = cb.EarlyStopping(monitor='loss', patience=5, mode='min')
lr = cb.ReduceLROnPlateau(monitor='val_loss', patience=3, mindelta=1e-1)

loss = tf.keras.losses.BinaryCrossentropy(from_logits=True)
optimizer = keras.optimizers.Adam(learning_rate=0.01)

keras_model.compile(loss=loss, optimizer=optimizer, metrics=['accuracy'])
fig

history = keras_model.fit(X_train, y_train, epochs=50, batch_size=512, callbacks=[es, lr])

train_loss = history.history['loss']
train_accuracy = history.history['accuracy']
plt.figure(figsize=(20, 10))
plt.subplot(1, 2, 2)
plt.plot(range(len(train_loss)), train_loss, label='train_loss')
plt.plot(range(len(train_accuracy)), train_accuracy, label='train_accuracy')
plt.legend();

"""# XGboost"""

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
model = RandomForestClassifier()

model.fit(X_train,y_train)
y_pred = model.predict(X_test)
print(classification_report(y_test,y_pred))
ConfusionMatrixDisplay.from_predictions(y_test,y_pred);

xgbc = XGBClassifier()

model.fit(X_train,y_train)
y_pred = model.predict(X_test)
print(classification_report(y_test,y_pred))
ConfusionMatrixDisplay.from_predictions(y_test,y_pred);

"""# Predict World Cup winner ​🥇​

"""

def get_team_data(team: str) -> list:
    # team total fifa points
    home_FP = df.loc[(df['home_team']==team).values & (df['year'] >= 2021).values & (df['away_team'].isin(teams_worldcup)).values, 'home_team_total_fifa_points'].mean()
    away_FP = df.loc[(df['away_team']==team).values & (df['year'] >= 2021).values & (df['home_team'].isin(teams_worldcup)).values, 'away_team_total_fifa_points'].mean()
    fifa_points = np.mean([home_FP, away_FP])
    if np.isnan(fifa_points):
        home_FP = df.loc[(df['home_team']==team).values & (df['away_team'].isin(teams_worldcup)).values, 'home_team_total_fifa_points'].iloc[:2].mean()
        away_FP = df.loc[(df['away_team']==team).values & (df['home_team'].isin(teams_worldcup)).values, 'away_team_total_fifa_points'].iloc[:3].mean()
        fifa_points = np.mean([home_FP, away_FP])

    
    # team fifa rank
    home_FR = df.loc[(df['home_team']==team).values & (df['year'] >= 2021).values & (df['away_team'].isin(teams_worldcup)).values, 'home_team_fifa_rank'].mean()
    away_FR = df.loc[(df['away_team']==team).values & (df['year'] >= 2021).values & (df['home_team'].isin(teams_worldcup)).values, 'away_team_fifa_rank'].mean()
    fifa_rank = np.mean([home_FR, away_FR])
    if np.isnan(fifa_rank):
        home_FR = df.loc[(df['home_team']==team).values & (df['away_team'].isin(teams_worldcup)).values, 'home_team_fifa_rank'].iloc[:2].mean()
        away_FR = df.loc[(df['away_team']==team).values & (df['home_team'].isin(teams_worldcup)).values, 'away_team_fifa_rank'].iloc[:3].mean()
        fifa_rank= np.mean([home_FR, away_FR])

    
    # team continent
    continent = df.loc[df['home_team']==team, 'home_team_continent_encoded'].mode()[0]
    
    # scores
    home_scores = df.loc[(df['home_team']==team).values & (df['away_team'].isin(teams_worldcup)).values].sort_values(by='date').drop('home_team_score', axis=1).filter(regex='score').filter(regex='home').iloc[:5].mean()
    away_scores = df.loc[(df['away_team']==team).values & (df['home_team'].isin(teams_worldcup)).values].sort_values(by='date').drop('away_team_score', axis=1).filter(regex='score').filter(regex='away').iloc[:5].mean()
    scores = (home_scores.values + away_scores.values) / 2
    
    
    return [fifa_rank, fifa_points, continent] +  [*scores]

def prepare_data(team1_data: list, team2_data: list, tournament_rank:str, shoot_out:bool) -> np.ndarray:
    fifa_pts_diff = team1_data[1] - team2_data[1]
    fifa_pts_sum = team1_data[1] + team2_data[1]
    fifa_rank_diff = team1_data[0] - team2_data[0]
    fifa_rank_sum = team1_data[0] + team2_data[0]
    tournaments = [*tournament_rank_encoder.transform(np.array(tournament_rank).reshape(-1, 1)).toarray()[0]]
    X = np.array([team1_data[0], team2_data[0], team1_data[1], team2_data[1], shoot_out, team1_data[3], team2_data[3], *team1_data[4:], *team2_data[4:],
                 fifa_pts_diff, fifa_pts_sum, fifa_rank_diff, fifa_rank_sum, *tournaments, team1_data[2], team2_data[2]])
    return X.reshape(-1, 26)

"""# Group Stage

"""

def predict_match(team1, team2, shoot_out=0):
    team1 = get_team_data(team1)
    team2 = get_team_data(team2)
    inp1 = prepare_data(team1, team2, 'International', shoot_out=shoot_out)
    y_pred1 = keras_model.predict(inp1)
    
    inp2 = prepare_data(team2, team1, 'International', shoot_out=shoot_out)
    y_pred2 = keras_model.predict(inp2)
    
    y_pred = (1 + y_pred1 - y_pred2) / 2
    return y_pred

def calc_points(team1, team2):
    y_pred = predict_match(team1, team2)
    if (y_pred>=0.55):
        return 3, 0
    elif (y_pred<=0.45):
        return 0, 3
    else :
        return 1, 1

groups = np.array(teams_worldcup).reshape(8, 4)
groups_pts = []
for i, group in enumerate(groups):
    print(f'Group {i+1}: ', end=f"\n{20*'-'}\n")
    groups_pts.append(dict(zip(group, np.zeros(4))))
    matches = [*combinations(group, 2)]
    
    # play matches
    for team1, team2 in matches:
        pt1, pt2 = calc_points(team1, team2)
        print(f"{team1} : {pt1} VS {team2} : {pt2}")
        groups_pts[i][team1] += pt1
        groups_pts[i][team2] += pt2
    print(30*'=')

sorted_groups_pts = []
def draw_break(groups_pts):
    for i, group_pts in enumerate(groups_pts):
        group = dict(reversed(sorted(group_pts.items(), key=lambda item: item[1])))
        teams = [*group.keys()]
        points = [*group.values()]
        
        if points[0] <= points[1]:
            out = predict_match(teams[0], teams[1])
            if out < 0.5:
                temp = teams[0]
                teams[0] = teams[1]
                teams[1] = temp

        if points[1] <= points[2]:
            out = predict_match(teams[1], teams[2])
            if out < 0.5:
                temp = teams[1]
                teams[1] = teams[2]
                teams[2] = temp
                
        sorted_groups_pts.append(dict(zip(teams, points)))
    return sorted_groups_pts
    
sorted_groups_pts = draw_break(groups_pts)

sorted_teams = []
print(colored("Groups after group stage: \n", 'red'))
for group in sorted_groups_pts:
    print(group, end=f'\n{50*"-"}\n')
    teams = [*group.keys()]
    sorted_teams.append(teams[:2])
    
# the round of 16
to_16 = []
for i in range(0, 8, 2):
    to_16.append((sorted_teams[i][0], sorted_teams[i+1][1]))
    to_16.append((sorted_teams[i+1][0], sorted_teams[i][1]))
    

to_8 = []
print(colored(f'\n{50*"="}\nMatches results in the round of 16:\n{50*"-"}', 'red'))
for i, (team1, team2) in enumerate(to_16):
    out =  predict_match(team1, team2, shoot_out=1)
    winner = team1 if out > 0.5 else team2
    print(f'Match{i+1}: {team1} VS {team2}')
    print(f'Winner: {colored(winner, "green")}')
    to_8.append(winner)

# the round of 8
# to_8 = to_8[::2] + to_8[1::2]
to_8 = np.array(to_8[::2] + to_8[1::2]).reshape(-1, 2)
to_4 = []
for i, (team1, team2) in enumerate(to_8):
    out =  predict_match(team1, team2, shoot_out=1)
    winner = team1 if out > 0.5 else team2
    print(f'Match{i+1}: {team1} VS {team2}')
    print(f'Winner: {colored(winner, "green")}')
    to_4.append(winner)

# the round of 4
to_4 = np.array(to_4).reshape(-1, 2)
to_final = []
to_third_place_playoff = []
for i, (team1, team2) in enumerate(to_4):
    out =  predict_match(team1, team2, shoot_out=1)
    winner = team1 if out > 0.5 else team2
    loser = team1 if out <= 0.5 else team2
    print(f'Match{i+1}: {team1} VS {team2}')
    print(f'Winner: {colored(winner, "green")}')
    to_final.append(winner)
    to_third_place_playoff.append(loser)

# third place play-off
third_out = predict_match(*to_third_place_playoff, shoot_out=1)
third = to_third_place_playoff[1 - int(third_out>0.5)]
fourth = to_third_place_playoff[int(third_out>0.5)]

# Final 
final_out = predict_match(*to_final, shoot_out=1)
Winner = to_final[1 - int(final_out>0.5)]
second = to_final[int(final_out>0.5)]

print(f"Winner of the World Cup Qatar 2022: {colored(Winner, 'yellow')}")
print(f"Second place of the World Cup Qatar 2022: {colored(second, 'red')}")
print(f"Third place of the World Cup Qatar 2022: {colored(third, 'blue')}")
print(f"Fourth place of the World Cup Qatar 2022:", end=' ')
cprint(fourth, 'blue', 'on_grey')

